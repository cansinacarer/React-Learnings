# Managing Uncontrolled Form Elements with useRef

Anytime you are using useRef, you are managing form components outside of the state.

You can disable the default form submit with `<form action="" onSubmit={submit}>` which is defined as:

```jsx
const submit = (e) => {
	e.preventDefault();
};
```

You can use **useRef** hook to get the value of an element in dom. Import it:

```js
import { useRef } from "react";
```

Then you can get the value of a form input with:

1. Define a variable with useRef();

    ```jsx
    const textTitle = useRef();
    ```

2. Assign this variable as a reference to the input

    ```jsx
    <input ref={textTitle} type="text" placeholder="Color title" />
    ```

3. Then you can access it with:

    ```jsx
    const title = textTitle.current.value;
    console.log(title);
    ```

4. You can also set them with `current.value`. E.g. for reseting after submission

    ```jsx
    textTitle.current.value = "";
    ```

So managing this form with uncontrolled components using useRef would be:

```jsx
import "./App.css";
import { useRef } from "react";

function App() {
	const textTitle = useRef();
	const hexColor = useRef();

	const submit = (e) => {
		// Prevent the default form behavior
		e.preventDefault();

		// Get the value of the input fields
		const title = textTitle.current.value;
		const color = hexColor.current.value;

		// Do something with it
		console.log(title, color);

		// Clear the form
		textTitle.current.value = "";
		hexColor.current.value = "#00ff00";
	};

	return (
		<form onSubmit={submit}>
			<input ref={textTitle} type="text" placeholder="Color title" />
			<input ref={hexColor} type="color" />
			<button>Add</button>
		</form>
	);
}

export default App;
```

# Managing Controlled Form Elements with useState

Contolled means we are creating state values for the form inputs:

-   Our variables would be the state values,
-   We'd replace ref attributes of the inputs with value attributes that point to states,
-   We'd need to listen to onChange event of the inputs and call the state change functions onChange:
    ```jsx
    <input
    	onChange={(event) => setTitle(event.target.value)}
    	value={title}
    	type="text"
    	placeholder="Color title"
    />
    ```
-   How we clear the form would also change, you don't just have variables to assign values like useRef, you need to call state update function.

    ```jsx
    setTitle("");
    setColor("#000000");
    ```

The difference between the two approach is:

-   With useRef, we are reading the input values and updating our variables only when the form is submitted,
-   With useState, we are continuously listening to onChange event of the input fields and updating our variables.

# Building a custom hook

A custom hook is a function, its name always starts with the word "use".

[THIS IS WHERE I LEFT](https://www.linkedin.com/learning/react-js-essential-training-14836121/building-a-custom-hook?autoSkip=true&resume=false&u=2174970)

# Form Libraries

They can help with validation, performance optimiziation (reducing re-renders); they abstract away the state management logic...
